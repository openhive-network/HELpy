# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2025-04-29T11:34:38+00:00

from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional


@dataclass
class Close:
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet
    """


@dataclass
class CloseResponse:
    pass


@dataclass
class CloseSession:
    token: str
    """
    Session's identifier
    """


@dataclass
class CloseSessionResponse:
    pass


@dataclass
class Create:
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet. Only alphanumeric and '._-@' chars are allowed. A maximum length depends on a maximum length of a file name in given OS.
    """
    is_temporary: Optional[bool] = None
    """
    If `true` the wallet exists only in memory otherwise is saved into a file.
    """
    password: Optional[str] = None
    """
    A password for a wallet, if not given will be automatically generated. Maximum length 128.
    """


@dataclass
class CreateResponse:
    password: Optional[str] = None
    """
    A plaintext password that is needed to unlock a wallet. A caller is responsible for saving the password otherwise it's impossible to unlock the wallet
    """


@dataclass
class CreateSession:
    notifications_endpoint: Optional[str] = None
    """
    A server attached to given session. It's used to receive notifications. Optional.
    """
    salt: Optional[str] = None
    """
    Random data that is used as an additional input so as to create a token. Optional.
    """


@dataclass
class CreateSessionResponse:
    token: Optional[str] = None
    """
    A token that is attached to newly created session
    """


@dataclass
class DecryptData:
    encrypted_content: str
    """
    A string to decrypt
    """
    from_public_key: str
    """
    A public key of creator
    """
    to_public_key: str
    """
    A public key of receiver
    """
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of the wallet to find a key corresponding to `from_public_key` or `to_public_key`. Only one private key is necessary
    """


@dataclass
class DecryptDataResponse:
    decrypted_content: Optional[str] = None
    """
    A decrypted string
    """


@dataclass
class EncryptData:
    content: str
    """
    A string to encrypt
    """
    from_public_key: str
    """
    A public key of creator
    """
    to_public_key: str
    """
    A public key of receiver
    """
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet to find a key corresponding to `from_public_key` and `to_public_key`
    """
    nonce: Optional[int] = None
    """
    If nonce is given then is used for encryption otherwise current time is used
    """


@dataclass
class EncryptDataResponse:
    encrypted_content: Optional[str] = None
    """
    An encrypted string
    """


@dataclass
class GetInfo:
    token: str
    """
    Session's identifier
    """


@dataclass
class GetInfoResponse:
    now: Optional[str] = None
    """
    Current time
    """
    timeout_time: Optional[str] = None
    """
    Timeout time
    """


@dataclass
class GetPublicKeys:
    token: str
    """
    Session's identifier
    """
    wallet_name: Optional[str] = None
    """
    If a wallet_name is given public keys are searched in a specific wallet otherwise in every unlocked wallet
    """


@dataclass
class GetPublicKeysResponseItem:
    public_key: Optional[str] = None
    """
    A public key
    """


GetPublicKeysResponse = List[GetPublicKeysResponseItem]


@dataclass
class GetVersion:
    pass


@dataclass
class GetVersionResponse:
    version: Optional[str] = None
    """
    Current version
    """


@dataclass
class HasMatchingPrivateKey:
    public_key: str
    """
    A public key corresponding to a private key that is stored in a wallet
    """
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet
    """


@dataclass
class HasMatchingPrivateKeyResponse:
    exists: Optional[bool] = None
    """
    A `true` value if a private key exists otherwise `false`
    """


@dataclass
class HasWallet:
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet
    """


@dataclass
class HasWalletResponse:
    exists: Optional[bool] = None
    """
    A `true` value if a wallet exists otherwise `false`
    """


@dataclass
class ImportKey:
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet to import into
    """
    wif_key: str
    """
    The WIF Private Key to import, e.g. 5JNHfZYKGaomSFvd4NUdQ9qMcEAC43kujbfjueTHpVapX1Kzq2n
    """


@dataclass
class ImportKeyResponse:
    public_key: Optional[str] = None
    """
    A public key corresponding to WIF key
    """


@dataclass
class ImportKeys:
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet to import into
    """
    wif_keys: List[str]


ImportKeysResponse = List[str]


@dataclass
class IsWalletUnlocked:
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet
    """


@dataclass
class IsWalletUnlockedResponse:
    is_locked: Optional[bool] = None
    """
    A `true` value if a wallet is unlocked otherwise `false`
    """


@dataclass
class ListCreatedWallets:
    token: str


@dataclass
class ListCreatedWalletsResponseItem:
    name: Optional[str] = None
    """
    A name of a wallet
    """
    unlocked: Optional[bool] = None
    """
    Status of a wallet
    """


ListCreatedWalletsResponse = List[ListCreatedWalletsResponseItem]


@dataclass
class ListWallets:
    token: str
    """
    Session's identifier
    """


@dataclass
class ListWalletsResponseItem:
    name: Optional[str] = None
    """
    A name of a wallet
    """
    unlocked: Optional[bool] = None
    """
    Status of a wallet
    """


ListWalletsResponse = List[ListWalletsResponseItem]


@dataclass
class Lock:
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet to lock
    """


@dataclass
class LockAll:
    token: str
    """
    Session's identifier
    """


@dataclass
class LockAllResponse:
    pass


@dataclass
class LockResponse:
    pass


@dataclass
class Open:
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet
    """


@dataclass
class OpenResponse:
    pass


@dataclass
class RemoveKey:
    public_key: str
    """
    The public key to find corresponding a private key to remove.
    """
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet to remove a private key from
    """


@dataclass
class RemoveKeyResponse:
    pass


@dataclass
class SetTimeout:
    seconds: int
    """
    After `N` seconds of inactivity `lock_all` is called
    """
    token: str
    """
    Session's identifier
    """


@dataclass
class SetTimeoutResponse:
    pass


@dataclass
class SignDigest:
    public_key: str
    """
    A public key corresponding to a private key that is stored in a wallet
    """
    sig_digest: str
    """
    A signature digest. Represents a whole transaction
    """
    token: str
    """
    Session's identifier
    """
    wallet_name: Optional[str] = None
    """
    A name of a wallet where a private key is stored. If not given, then a private key is searched in all unlocked wallets
    """


@dataclass
class SignDigestResponse:
    signature: Optional[str] = None
    """
    A signature of a transaction
    """


@dataclass
class Unlock:
    password: str
    """
    The plaintext password
    """
    token: str
    """
    Session's identifier
    """
    wallet_name: str
    """
    A name of a wallet to unlock
    """


@dataclass
class UnlockResponse:
    pass


ImportKeysResponseItem = str
beekeeper_api_description = {
    "beekeeper_api": {
        "close": {
            "params": Close,
            "result": CloseResponse,
            "description": "Closing implicitly locks the wallet",
        },
        "close_session": {
            "params": CloseSession,
            "result": CloseSessionResponse,
            "description": "In case when all sessions are closed, the beekeeper is closed as well",
        },
        "create": {
            "params": Create,
            "result": CreateResponse,
            "description": "A new wallet is created in file dir/{wallet_name}.wallet. The new wallet is unlocked after creation and is implictly opened",
        },
        "create_session": {
            "params": CreateSession,
            "result": CreateSessionResponse,
            "description": "An unique token is generated. The token represents current session.",
        },
        "decrypt_data": {
            "params": DecryptData,
            "result": DecryptDataResponse,
            "description": "Decrypt given content. Using creator's and receivers's public keys, content is decrypted. Private keys must exist in given wallet",
        },
        "encrypt_data": {
            "params": EncryptData,
            "result": EncryptDataResponse,
            "description": "Encrypt given content. Using creator's and receivers's public keys, content is encrypted",
        },
        "get_info": {
            "params": GetInfo,
            "result": GetInfoResponse,
            "description": "Get current and timeout time connected with current session",
        },
        "get_public_keys": {
            "params": GetPublicKeys,
            "result": GetPublicKeysResponseItem,
            "description": "List all public keys from one wallet if a wallet_name is given otherwise all public keys from all unlocked wallets.",
            "response_array": True,
        },
        "get_version": {
            "params": GetVersion,
            "result": GetVersionResponse,
            "description": "Get current version. The version is based on git hash.",
        },
        "has_matching_private_key": {
            "params": HasMatchingPrivateKey,
            "result": HasMatchingPrivateKeyResponse,
            "description": "Tests if a private key corresponding to a public key exists in a wallet",
        },
        "has_wallet": {
            "params": HasWallet,
            "result": HasWalletResponse,
            "description": "Tests if a wallet exists",
        },
        "import_key": {
            "params": ImportKey,
            "result": ImportKeyResponse,
            "description": "Import a private key into specified wallet",
        },
        "import_keys": {
            "params": ImportKeys,
            "result": ImportKeysResponseItem,
            "description": "Import private keys into specified wallet",
            "response_array": True,
        },
        "is_wallet_unlocked": {
            "params": IsWalletUnlocked,
            "result": IsWalletUnlockedResponse,
            "description": "Display information if given wallet is locked or not",
        },
        "list_created_wallets": {
            "params": ListCreatedWallets,
            "result": ListCreatedWalletsResponseItem,
            "description": "List all created wallets stored physically in a directory pointed by the beekeeper. It doesn't matter if these wallets are opened/unlocked",
            "response_array": True,
        },
        "list_wallets": {
            "params": ListWallets,
            "result": ListWalletsResponseItem,
            "description": "List all opened wallets with information if given wallet is locked or not",
            "response_array": True,
        },
        "lock": {
            "params": Lock,
            "result": LockResponse,
            "description": "A wallet is locked and it is not possible to execute any operations related to the wallet. Signing a transaction is blocked",
        },
        "lock_all": {
            "params": LockAll,
            "result": LockAllResponse,
            "description": "All unlocked wallets are locked and implicitly closed",
        },
        "open": {
            "params": Open,
            "result": OpenResponse,
            "description": "Open an existing wallet. Opening does not unlock the wallet",
        },
        "remove_key": {
            "params": RemoveKey,
            "result": RemoveKeyResponse,
            "description": "Remove a private key. Important! It is highly recommended to backup the key earlier. This operation can be reverted.",
        },
        "set_timeout": {
            "params": SetTimeout,
            "result": SetTimeoutResponse,
            "description": "Set a timeout in order to lock all wallets when time passes",
        },
        "sign_digest": {
            "params": SignDigest,
            "result": SignDigestResponse,
            "description": "Sign a transaction presented as a sig_digest using a private key corresponding to a public key",
        },
        "unlock": {
            "params": Unlock,
            "result": UnlockResponse,
            "description": "A wallet is unlocked and it is possible to execute some operations related to the wallet including a transaction signing. Unlocking implicitly opens the wallet",
        },
    }
}

